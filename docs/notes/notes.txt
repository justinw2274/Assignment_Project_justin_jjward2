## Initial Brainstorming
I considered three different angles for the paper trading and backtesting platform.

1.  **Manual Backtester:** A platform where a user could manually step through historical data candle by candle and simulate "buying" or "selling." The app would track the P/L. This would be easy to implement but not very powerful.

2.  **Backtester with Pre-built Strategies:** A platform with a few hard-coded strategies (e.g., a simple moving average crossover) that a user could run on different stocks. This would demonstrate backtesting but wouldn't allow for user creativity.

3.  **Simple Strategy Builder with Real-Time Simulation:** A platform where users can define their own simple, rule-based strategies (e.g., "buy when RSI is below 30"). The app would then connect to a brokerage API (like Alpaca) to run the strategy against historical data (backtesting) and simulate it in real-time with live data (paper trading).

## Selection Rationale
I have selected **Idea #3, the Simple Strategy Builder with Real-Time Simulation**.

This idea provides the best balance of features for an assignment of this scope. It introduces several key concepts essential for building trading systems: API integration for data, building a backtesting engine, and simulating real-time events. While the strategy builder itself will be simple, it provides a solid foundation and a much more engaging and realistic experience than a purely manual or pre-canned system. The technical challenges, like handling API data and asynchronous tasks, make it a great learning experience.




#######################################
# Wireframe Notes
#######################################

The wireframes for this platform prioritize real-time information and a clear, intuitive interface for building and monitoring strategies.

*   **login.png:** A straightforward and secure login screen to protect user-created strategies and portfolio data.

*   **dashboard.png:** The dashboard is focused on live data. The most critical information—current portfolio value and live P/L—is displayed prominently at the top for immediate feedback. The live chart and open positions table provide the necessary details for monitoring the strategy's performance in real-time.

*   **core_feature.png (Strategy Builder):** The design of the strategy builder aims for simplicity. Using dropdowns to construct rules (e.g., "IF-THEN") makes it accessible even to users without a programming background. The goal is to allow for the creation of simple, rule-based strategies without overwhelming the user.

*   **error_state.png:** I chose to show an API connection error for the error state. Since this application depends on an external data source, handling connection failures is a critical aspect of the user experience. The "Retry Connection" button provides an immediate, actionable step for the user.





#######################################
# Branching Strategy
#######################################

## Strategy Choice: Feature Branching

I have chosen a simple and effective **Feature Branching** model for this project. This is a standard workflow that is ideal for solo developers and teams alike.

## Branch Definitions

*   **`main`**: This is the primary branch of the repository. It will be kept clean and will always represent a stable, working version of the project. No direct commits will be made to `main`.

*   **`feature/<feature-name>`**: All new work will be done on a dedicated feature branch. These branches will be created from `main` for a single, specific task (e.g., `feature/user-authentication` or `feature/dashboard-chart`).

## Workflow

The development process will follow these steps:
1.  Create a new `feature/` branch from the `main` branch.
2.  Perform all work and make all commits for that feature on its branch.
3.  Once the feature is complete and tested, it will be merged back into the `main` branch.
4.  The feature branch can then be deleted.

## Rationale for this Choice

This strategy keeps the `main` branch clean, stable, and always in a deployable state. It isolates the development of new features, preventing unstable or in-progress code from breaking the main application. This makes it much easier to manage individual tasks, track changes, and debug issues without disrupting the entire project.



#######################################
# Django Setup
#######################################

Project Name: `backtesting_platform`. This name was chosen to clearly define the project's primary purpose as the main settings holder for the backtesting and simulation features.

App Name: `paper_trader`. I named this app to reflect its core function, which will be to handle the logic for running trading strategies, connecting to the brokerage API, and managing the real-time simulation dashboard.

#######################################
# Virtual Environment Choices
#######################################

Choice: `venv`

Reason: I chose `venv` because it is the standard, built-in virtual environment tool for Python 3. It requires no external installation, is lightweight, and integrates seamlessly with any workflow. It is the official recommendation from the Python community and is perfectly capable of managing all the dependencies for this Django project.


#######################################
# Week 4: Data Model and Admin Setup
#######################################

## Model & Field Rationale
I designed three core models to represent the project's data structure:

1.  **Strategy**: This is the parent model. Each user-defined strategy is a unique entity with a name and description. `name` is unique to prevent duplicate strategies.
2.  **Rule**: This model defines the logic of a strategy. A strategy is composed of one or more rules.
3.  **Trade**: This records the simulated trades executed by a strategy, creating a historical log of performance.

## Relationship Choices
*   **Rule -> Strategy (ForeignKey, `on_delete=models.CASCADE`)**: A rule is meaningless without its parent strategy. If a strategy is deleted, all of its defining rules should be deleted along with it. This maintains database integrity automatically.
*   **Trade -> Strategy (ForeignKey, `on_delete=models.PROTECT`)**: It is critical to preserve the historical record of trades. `PROTECT` prevents the accidental deletion of a strategy if it has trades associated with it. This forces a deliberate action to delete the trades first, acting as a valuable safety feature.

## Constraints and Ordering
*   **UniqueConstraint (Rule model)**: I added a `UniqueConstraint` on the fields `['strategy', 'indicator', 'operator', 'value']`. This prevents a user from creating two identical rules within the same strategy (e.g., two "RSI > 70" rules), which would be redundant and illogical.
*   **Ordering**: Strategies are ordered by `name` for easy browsing. Trades are ordered by `-trade_date` (descending) to show the most recent activity first, which is the most common use case.

## Test Data Seeding
I used the Django Admin interface to seed the test data.
1.  Created two strategies: "Momentum Breakout" and "Mean Reversion".
2.  Added rules to each, and verified the `UniqueConstraint` by attempting to add a duplicate rule, which failed as expected.
3.  Added 7 trades and linked them to the strategies.
4.  Verified the `on_delete=PROTECT` constraint by attempting to delete a strategy that had trades, which also failed as expected. This confirms the relationships and protections are working correctly.

**Why Two Views?**
The purpose of writing two separate views was to directly compare the manual, low-level process of returning an HTTP response with Django's high-level `render()` shortcut. This exercise demonstrates how `render()` abstracts away the steps of loading a template and packaging it into an `HttpResponse`, which reduces boilerplate code and improves readability.

**Difference Between HttpResponse and render()**
- `HttpResponse`: This is the fundamental building block. You must manually perform every step: load the template file using `loader.get_template()`, render it with a context dictionary, and then pass the resulting HTML string into an `HttpResponse` object. It gives you full control but is verbose.
- `render()`: This is a shortcut function that handles the entire process in one line. It takes the `request` object, the path to the template, and a context dictionary as arguments. Behind the scenes, it performs the same steps as the manual method (loading, rendering, and wrapping in `HttpResponse`) and returns the final object. It is the preferred, idiomatic way to render templates in Django.

**URL and Template Decisions**
I created two distinct URLs (`/trades/http/` and `/trades/render/`) to make it easy to test and verify each view independently. Both views intentionally use the exact same template (`trade_list.html`). This highlights that templates are decoupled from the view logic; they only need a context dictionary named `trades` to function correctly, regardless of how the view prepares it.


--- Assignment 5 Notes ---

**Difference Between Base and Generic Class-Based Views:**
A base CBV (inheriting from `View`) is the foundational class. It requires you to manually implement methods for each HTTP verb you want to handle (e.g., `def get(self, request):`, `def post(self, request):`). You are in full control but must write all the logic yourself.

A generic CBV (like `ListView` or `DetailView`) inherits from the base `View` but comes with a great deal of pre-built functionality for common use cases. For a `ListView`, you simply specify the model, and it automatically handles querying the database for all objects, passing them to a template, and rendering the response.

**Why Generic Views Reduce Boilerplate:**
Generic views abstract away the most common patterns in web development. Instead of repeatedly writing "get all objects from this model and render them with this template," you can declare those intentions with a few class attributes (`model`, `template_name`). This makes the code shorter, faster to write, and less prone to simple errors.

**Why URL Refactoring Improves Maintainability:**
Refactoring the project's URL structure to use `include()` makes the project more organized and scalable. It decouples the project's URL configuration from the app's internal URLs. This means you can easily reuse the `paper_trader` app in another project, or change its root URL (e.g., move it from `/` to `/trading/`) by changing only one line in the main `urls.py` file, without having to modify any of the app's internal URL patterns.


--- Assignment 6 Notes ---

**Filtering vs. Aggregation**
*   **Filtering:** Narrows down a set of data. It reduces the number of rows in a queryset based on a condition (e.g., showing only strategies where the name contains "Momentum"). It answers the question, "Which items match this criteria?"
*   **Aggregation:** Computes a single summary value from a set of data (e.g., the total count of all strategies). It answers the question, "What is the total/average/sum of these items?"
*   **Annotation:** A special type of aggregation that calculates a summary value for *each* item in a queryset, adding it as a new field to each object. For example, calculating the number of trades for each individual strategy.

**Project Summary Statistics:**
*   **Total Strategies:** A simple count of all `Strategy` objects in the database, providing a high-level overview of how many strategies have been created.
*   **Rules per Strategy:** This breakdown shows how many `Rule` objects are linked to each `Strategy`. It helps identify which strategies are simple (e.g., 1 rule) versus which are more complex (e.g., 5+ rules).
*   **Trades per Strategy:** This shows how many `Trade` objects are associated with each `Strategy`. It's a quick way to see which strategies have been most active in simulations.


--- Assignment 7 Notes ---

**How Static Files Work in Django:**
*   Static files (CSS, JavaScript, images) are assets that don't change. They are placed in a dedicated `static` directory, typically namespaced within each app (e.g., `app/static/app/`).
*   To use them in a template, you must first include `{% load static %}` at the top.
*   The `{% static 'path/to/file.css' %}` template tag generates the correct URL for the asset, ensuring it works in both development and production environments.

**Dynamic Chart Generation with Matplotlib:**
*   The chart is generated in a dedicated Django view, not as a static file.
*   The view first performs a database query using the ORM's `.annotate()` and `Count()` functions to get the data (e.g., the number of rules for each strategy).
*   Matplotlib is then used to create a chart (in this case, a horizontal bar chart) from that data.

**Key Functions & Concepts:**
*   **`matplotlib.use('Agg')`**: This is a crucial line for running Matplotlib in a web server environment. It switches Matplotlib to a non-interactive "backend" that renders charts to a buffer instead of trying to open a GUI window, which would crash the server (especially on macOS).
*   **`io.BytesIO`**: This creates a binary file in memory. Instead of saving the chart image to the disk, Matplotlib saves it directly into this memory buffer.
*   **`HttpResponse(buffer.getvalue(), content_type='image/png')`**: The view reads the binary content from the `BytesIO` buffer and returns it in an `HttpResponse`, telling the browser that it is receiving a PNG image.
*   **`plt.tight_layout()`**: A helpful Matplotlib function that automatically adjusts the chart's padding and spacing to ensure all elements (like labels and titles) fit neatly without overlapping.

**Chart Explanation:**
*   The bar chart on the Strategy Dashboard provides a quick visual reference for the complexity of each strategy by displaying the number of rules associated with it.


--- Assignment 8 Notes ---

**Key Concepts in Django Forms:**

*   **GET vs. POST Methods:**
    *   **GET** is used for safe, idempotent requests like searching or filtering. Data is sent in the URL (`?q=...`), which is bookmarkable but insecure for sensitive information.
    *   **POST** is used for requests that change server state, like creating or updating an object. Data is sent in the request body, which is more secure and can handle large amounts of data.

*   **What CSRF Is and Why It's Needed:**
    *   CSRF stands for Cross-Site Request Forgery. It's an attack where a malicious site tricks a user into performing an unwanted action on a site where they are authenticated.
    *   The `{% csrf_token %}` tag adds a hidden, unique token to your POST forms. Django verifies this token on submission to ensure the request originated from your own site, thus preventing the attack.

*   **Django's Form Submission Process:**
    1.  A `GET` request is made to the URL, and the view renders the template with an empty form instance.
    2.  The user fills out the form and submits it, making a `POST` request to the same URL.
    3.  The view creates a form instance populated with the `request.POST` data.
    4.  `form.is_valid()` is called, which runs all validation checks (including our custom `clean_name` method).
    5.  If invalid, the view re-renders the template with the same form instance, which now contains error messages.
    6.  If valid, the data is processed (e.g., `form.save()`), and the user is redirected to a success page.

*   **Pros and Cons of FBV vs. CBV for Forms:**
    *   **Function-Based Views (FBVs):**
        *   *Pros:* Explicit, easy to read for simple logic, and offers complete control over the workflow.
        *   *Cons:* Can lead to repetitive boilerplate code, especially for standard CRUD (Create, Read, Update, Delete) operations.
    *   **Class-Based Views (CBVs):**
        *   *Pros:* Highly reusable, follows the Don't Repeat Yourself (DRY) principle, and handles common patterns with very little code (e.g., `CreateView`).
        *   *Cons:* Can be harder to understand and customize because much of the logic is inherited and implicit.


--- Assignment 9 Notes ---

**What is a JSON API?**
*   A JSON API is an interface that allows different applications to communicate with each other by sending and receiving data formatted as JSON (JavaScript Object Notation).
*   It defines a set of URLs (endpoints) where a client can send a request (like GET or POST) to retrieve or manipulate data, and the server responds with structured JSON data, not HTML.

**HttpResponse vs. JsonResponse:**
*   **`HttpResponse`** is a general-purpose class that can return any type of content. You must manually set the `content_type` header (e.g., `text/plain`, `image/png`). It returns a raw string or byte string.
*   **`JsonResponse`** is a specialized subclass of `HttpResponse`. It automatically handles serializing a Python dictionary into JSON format and sets the `Content-Type` header to `application/json`. This is the standard and correct way to return API data in Django.

**Chart Data Flow:**
1.  A user requests the HTML page for the chart (`/charts/dashboard/`).
2.  The template for that page contains an `<img>` tag whose `src` attribute points to the chart-generating URL (`/charts/api_driven_chart.png`).
3.  The browser then makes a second request to this chart URL.
4.  The `api_driven_chart_view` receives this request, and it in turn makes an internal request to our own API (`/api/strategies/summary/`) using `urllib.request`.
5.  The view parses the JSON data from the API response.
6.  It uses this parsed data to generate a chart with Matplotlib.
7.  The chart is saved to an in-memory buffer (`io.BytesIO`) and returned as an `HttpResponse` with a `content_type` of `image/png`.
8.  The browser receives this image data and displays it inside the `<img>` tag.



--- Assignment 10 Notes ---

**API Selection:**
*   I chose the CoinGecko API because it provides free, real-time cryptocurrency price data with no API key required.
*   This is directly relevant to my paper trading platform, as users can view current prices to help make informed trading decisions.
*   Endpoint used: `https://api.coingecko.com/api/v3/simple/price`

**Fields Extracted:**
*   From the full API response, I extracted only two key fields to keep the output clean:
    *   `coin`: The cryptocurrency ID (e.g., "bitcoin", "ethereum").
    *   `price_usd`: The current price in US dollars.

**Error Handling:**
*   Used a `try/except` block to catch `requests.exceptions.RequestException`, which covers network errors, connection timeouts, and more.
*   Set a 5-second timeout on the API call to prevent the page from hanging indefinitely if the external service is slow or unresponsive.
*   Called `.raise_for_status()` to automatically raise an exception for any HTTP error response (4xx or 5xx status codes).
*   If an error occurs, the view renders the template with an error message instead of crashing.

**Final Data Structure:**
*   The trimmed data passed to the template is a list of dictionaries, which is simple and easy to loop through:
    ```
    [
        {"coin": "bitcoin", "price_usd": 34567.89},
        {"coin": "ethereum", "price_usd": 1823.45}
    ]
    ```

**API Limitations and Quirks:**
*   The CoinGecko free API has rate limits (approximately 10-50 calls per minute), but this is more than sufficient for a demo project.
*   Coin IDs must be exact matches (e.g., "bitcoin" works, but "Bitcoin" or "BTC" do not). The API documentation provides a full list of valid IDs.
*   If an invalid coin ID is provided, the API simply returns an empty result for that ID rather than throwing an error, which is why clear messaging in the template is important.



--- Assignment 11: Exports and Reports ---

- **How CSV and JSON are Generated:**
  - The export views use Django's `HttpResponse` and `JsonResponse` respectively.
  - For CSV, Python's built-in `csv` library is used to write headers and row data directly to the response object.
  - For JSON, a Python dictionary containing the data is passed to `JsonResponse`, which handles the serialization. `json_dumps_params={'indent': 2}` is used for pretty-printing.
  - The `Content-Disposition` header is set in both views to tell the browser to treat the response as a downloadable file and to provide a timestamped filename.

- **Metadata and Columns:**
  - The **CSV export** includes the columns: `ID`, `Name`, and `Description`.
  - The **JSON export** is a dictionary containing `generated_at` (an ISO timestamp), `record_count`, and a list of `strategies`, where each strategy is a dictionary with its `id`, `name`, and `description`.

- **Report Summaries:**
  - The reports page displays two main grouped summaries in tables:
    1.  **Rules per Strategy:** Shows each strategy and a count of how many rules are associated with it.
    2.  **Trade Value per Strategy:** Shows each strategy and the sum of its associated trade quantities.
  - It also includes a line for the "Total Active Strategies."
  - The `{% empty %}` template tag is used in each table to show a user-friendly message if there is no data to display.
