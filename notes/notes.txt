## Initial Brainstorming
I considered three different angles for the paper trading and backtesting platform.

1.  **Manual Backtester:** A platform where a user could manually step through historical data candle by candle and simulate "buying" or "selling." The app would track the P/L. This would be easy to implement but not very powerful.

2.  **Backtester with Pre-built Strategies:** A platform with a few hard-coded strategies (e.g., a simple moving average crossover) that a user could run on different stocks. This would demonstrate backtesting but wouldn't allow for user creativity.

3.  **Simple Strategy Builder with Real-Time Simulation:** A platform where users can define their own simple, rule-based strategies (e.g., "buy when RSI is below 30"). The app would then connect to a brokerage API (like Alpaca) to run the strategy against historical data (backtesting) and simulate it in real-time with live data (paper trading).

## Selection Rationale
I have selected **Idea #3, the Simple Strategy Builder with Real-Time Simulation**.

This idea provides the best balance of features for an assignment of this scope. It introduces several key concepts essential for building trading systems: API integration for data, building a backtesting engine, and simulating real-time events. While the strategy builder itself will be simple, it provides a solid foundation and a much more engaging and realistic experience than a purely manual or pre-canned system. The technical challenges, like handling API data and asynchronous tasks, make it a great learning experience.




#######################################
# Wireframe Notes
#######################################

The wireframes for this platform prioritize real-time information and a clear, intuitive interface for building and monitoring strategies.

*   **login.png:** A straightforward and secure login screen to protect user-created strategies and portfolio data.

*   **dashboard.png:** The dashboard is focused on live data. The most critical information—current portfolio value and live P/L—is displayed prominently at the top for immediate feedback. The live chart and open positions table provide the necessary details for monitoring the strategy's performance in real-time.

*   **core_feature.png (Strategy Builder):** The design of the strategy builder aims for simplicity. Using dropdowns to construct rules (e.g., "IF-THEN") makes it accessible even to users without a programming background. The goal is to allow for the creation of simple, rule-based strategies without overwhelming the user.

*   **error_state.png:** I chose to show an API connection error for the error state. Since this application depends on an external data source, handling connection failures is a critical aspect of the user experience. The "Retry Connection" button provides an immediate, actionable step for the user.





#######################################
# Branching Strategy
#######################################

## Strategy Choice: Feature Branching

I have chosen a simple and effective **Feature Branching** model for this project. This is a standard workflow that is ideal for solo developers and teams alike.

## Branch Definitions

*   **`main`**: This is the primary branch of the repository. It will be kept clean and will always represent a stable, working version of the project. No direct commits will be made to `main`.

*   **`feature/<feature-name>`**: All new work will be done on a dedicated feature branch. These branches will be created from `main` for a single, specific task (e.g., `feature/user-authentication` or `feature/dashboard-chart`).

## Workflow

The development process will follow these steps:
1.  Create a new `feature/` branch from the `main` branch.
2.  Perform all work and make all commits for that feature on its branch.
3.  Once the feature is complete and tested, it will be merged back into the `main` branch.
4.  The feature branch can then be deleted.

## Rationale for this Choice

This strategy keeps the `main` branch clean, stable, and always in a deployable state. It isolates the development of new features, preventing unstable or in-progress code from breaking the main application. This makes it much easier to manage individual tasks, track changes, and debug issues without disrupting the entire project.



#######################################
# Branch Usage Reflections
#######################################

I created the `feat/add-wireframes` branch to hold the initial design assets (wireframes and branching diagram). This work was done separately from the `main` branch to keep the main codebase clean and stable. The commit messages on this branch clearly document the addition of these design artifacts. Pushing the branch to GitHub makes this work visible and available for review without affecting the primary `main` branch.


