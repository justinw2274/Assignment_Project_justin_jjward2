## Initial Brainstorming
I considered three different angles for the paper trading and backtesting platform.

1.  **Manual Backtester:** A platform where a user could manually step through historical data candle by candle and simulate "buying" or "selling." The app would track the P/L. This would be easy to implement but not very powerful.

2.  **Backtester with Pre-built Strategies:** A platform with a few hard-coded strategies (e.g., a simple moving average crossover) that a user could run on different stocks. This would demonstrate backtesting but wouldn't allow for user creativity.

3.  **Simple Strategy Builder with Real-Time Simulation:** A platform where users can define their own simple, rule-based strategies (e.g., "buy when RSI is below 30"). The app would then connect to a brokerage API (like Alpaca) to run the strategy against historical data (backtesting) and simulate it in real-time with live data (paper trading).

## Selection Rationale
I have selected **Idea #3, the Simple Strategy Builder with Real-Time Simulation**.

This idea provides the best balance of features for an assignment of this scope. It introduces several key concepts essential for building trading systems: API integration for data, building a backtesting engine, and simulating real-time events. While the strategy builder itself will be simple, it provides a solid foundation and a much more engaging and realistic experience than a purely manual or pre-canned system. The technical challenges, like handling API data and asynchronous tasks, make it a great learning experience.




#######################################
# Wireframe Notes
#######################################

The wireframes for this platform prioritize real-time information and a clear, intuitive interface for building and monitoring strategies.

*   **login.png:** A straightforward and secure login screen to protect user-created strategies and portfolio data.

*   **dashboard.png:** The dashboard is focused on live data. The most critical information—current portfolio value and live P/L—is displayed prominently at the top for immediate feedback. The live chart and open positions table provide the necessary details for monitoring the strategy's performance in real-time.

*   **core_feature.png (Strategy Builder):** The design of the strategy builder aims for simplicity. Using dropdowns to construct rules (e.g., "IF-THEN") makes it accessible even to users without a programming background. The goal is to allow for the creation of simple, rule-based strategies without overwhelming the user.

*   **error_state.png:** I chose to show an API connection error for the error state. Since this application depends on an external data source, handling connection failures is a critical aspect of the user experience. The "Retry Connection" button provides an immediate, actionable step for the user.





#######################################
# Branching Strategy
#######################################

## Strategy Choice: Feature Branching

I have chosen a simple and effective **Feature Branching** model for this project. This is a standard workflow that is ideal for solo developers and teams alike.

## Branch Definitions

*   **`main`**: This is the primary branch of the repository. It will be kept clean and will always represent a stable, working version of the project. No direct commits will be made to `main`.

*   **`feature/<feature-name>`**: All new work will be done on a dedicated feature branch. These branches will be created from `main` for a single, specific task (e.g., `feature/user-authentication` or `feature/dashboard-chart`).

## Workflow

The development process will follow these steps:
1.  Create a new `feature/` branch from the `main` branch.
2.  Perform all work and make all commits for that feature on its branch.
3.  Once the feature is complete and tested, it will be merged back into the `main` branch.
4.  The feature branch can then be deleted.

## Rationale for this Choice

This strategy keeps the `main` branch clean, stable, and always in a deployable state. It isolates the development of new features, preventing unstable or in-progress code from breaking the main application. This makes it much easier to manage individual tasks, track changes, and debug issues without disrupting the entire project.



#######################################
# Django Setup
#######################################

Project Name: `backtesting_platform`. This name was chosen to clearly define the project's primary purpose as the main settings holder for the backtesting and simulation features.

App Name: `paper_trader`. I named this app to reflect its core function, which will be to handle the logic for running trading strategies, connecting to the brokerage API, and managing the real-time simulation dashboard.

#######################################
# Virtual Environment Choices
#######################################

Choice: `venv`

Reason: I chose `venv` because it is the standard, built-in virtual environment tool for Python 3. It requires no external installation, is lightweight, and integrates seamlessly with any workflow. It is the official recommendation from the Python community and is perfectly capable of managing all the dependencies for this Django project.


#######################################
# Week 4: Data Model and Admin Setup
#######################################

## Model & Field Rationale
I designed three core models to represent the project's data structure:

1.  **Strategy**: This is the parent model. Each user-defined strategy is a unique entity with a name and description. `name` is unique to prevent duplicate strategies.
2.  **Rule**: This model defines the logic of a strategy. A strategy is composed of one or more rules.
3.  **Trade**: This records the simulated trades executed by a strategy, creating a historical log of performance.

## Relationship Choices
*   **Rule -> Strategy (ForeignKey, `on_delete=models.CASCADE`)**: A rule is meaningless without its parent strategy. If a strategy is deleted, all of its defining rules should be deleted along with it. This maintains database integrity automatically.
*   **Trade -> Strategy (ForeignKey, `on_delete=models.PROTECT`)**: It is critical to preserve the historical record of trades. `PROTECT` prevents the accidental deletion of a strategy if it has trades associated with it. This forces a deliberate action to delete the trades first, acting as a valuable safety feature.

## Constraints and Ordering
*   **UniqueConstraint (Rule model)**: I added a `UniqueConstraint` on the fields `['strategy', 'indicator', 'operator', 'value']`. This prevents a user from creating two identical rules within the same strategy (e.g., two "RSI > 70" rules), which would be redundant and illogical.
*   **Ordering**: Strategies are ordered by `name` for easy browsing. Trades are ordered by `-trade_date` (descending) to show the most recent activity first, which is the most common use case.

## Test Data Seeding
I used the Django Admin interface to seed the test data.
1.  Created two strategies: "Momentum Breakout" and "Mean Reversion".
2.  Added rules to each, and verified the `UniqueConstraint` by attempting to add a duplicate rule, which failed as expected.
3.  Added 7 trades and linked them to the strategies.
4.  Verified the `on_delete=PROTECT` constraint by attempting to delete a strategy that had trades, which also failed as expected. This confirms the relationships and protections are working correctly.

**Why Two Views?**
The purpose of writing two separate views was to directly compare the manual, low-level process of returning an HTTP response with Django's high-level `render()` shortcut. This exercise demonstrates how `render()` abstracts away the steps of loading a template and packaging it into an `HttpResponse`, which reduces boilerplate code and improves readability.

**Difference Between HttpResponse and render()**
- `HttpResponse`: This is the fundamental building block. You must manually perform every step: load the template file using `loader.get_template()`, render it with a context dictionary, and then pass the resulting HTML string into an `HttpResponse` object. It gives you full control but is verbose.
- `render()`: This is a shortcut function that handles the entire process in one line. It takes the `request` object, the path to the template, and a context dictionary as arguments. Behind the scenes, it performs the same steps as the manual method (loading, rendering, and wrapping in `HttpResponse`) and returns the final object. It is the preferred, idiomatic way to render templates in Django.

**URL and Template Decisions**
I created two distinct URLs (`/trades/http/` and `/trades/render/`) to make it easy to test and verify each view independently. Both views intentionally use the exact same template (`trade_list.html`). This highlights that templates are decoupled from the view logic; they only need a context dictionary named `trades` to function correctly, regardless of how the view prepares it.


--- Assignment 5 Notes ---

**Difference Between Base and Generic Class-Based Views:**
A base CBV (inheriting from `View`) is the foundational class. It requires you to manually implement methods for each HTTP verb you want to handle (e.g., `def get(self, request):`, `def post(self, request):`). You are in full control but must write all the logic yourself.

A generic CBV (like `ListView` or `DetailView`) inherits from the base `View` but comes with a great deal of pre-built functionality for common use cases. For a `ListView`, you simply specify the model, and it automatically handles querying the database for all objects, passing them to a template, and rendering the response.

**Why Generic Views Reduce Boilerplate:**
Generic views abstract away the most common patterns in web development. Instead of repeatedly writing "get all objects from this model and render them with this template," you can declare those intentions with a few class attributes (`model`, `template_name`). This makes the code shorter, faster to write, and less prone to simple errors.

**Why URL Refactoring Improves Maintainability:**
Refactoring the project's URL structure to use `include()` makes the project more organized and scalable. It decouples the project's URL configuration from the app's internal URLs. This means you can easily reuse the `paper_trader` app in another project, or change its root URL (e.g., move it from `/` to `/trading/`) by changing only one line in the main `urls.py` file, without having to modify any of the app's internal URL patterns.